---
title: "macOSネイティブでコンテナイメージをクロスコンパイルする"
emoji: "🐋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nix", "container", "docker"]
published: true
---

## はじめに

macOSでコンテナ開発を行うとき、特にApple Silicon（M1/M2）搭載のMacを使用している場合、マルチアーキテクチャ対応のコンテナイメージを作成するには課題がある。

macOSでのコンテナ実行環境は、主に複数の仮想化技術に依存している。Docker Desktopは従来はHyperKit（macOSのHypervisor.framework上に構築）を利用していたが、現在ではApple Silicon向けにVirtualization Frameworkも採用し、LinuxKit VMを使用してコンテナを実行している。Rancher DesktopはLima VMを活用しており、内部的にはQEMUを使用している。最近のバージョンではApple Silicon向けにVirtualization Frameworkのサポートも追加された。Limaは「macOS向けのWSL2」とも呼ばれ、QEMUを利用して軽量Linuxマシンを実行する仕組みである。

これらの仮想化技術は便利だが、特に異なるアーキテクチャ（例：Intel/AMD向けのx86_64）向けのコンテナを実行・ビルドする場合、エミュレーションによるオーバーヘッドが発生し、ビルド時間の長さやリソース消費の問題が生じる。さらに、macOSでは仮想環境をネストして実行することが難しいという技術的制約があり、仮想化環境内で別の仮想化環境を実行する必要がある場合に問題となる。

この記事では、Nixを活用してmacOS上で直接異なるアーキテクチャ（aarch64-linuxやx86_64-linux）向けのコンテナイメージをクロスコンパイルする方法を紹介する。この方法を使うことで、仮想化やエミュレーションを使わずに、高速かつ効率的にマルチアーキテクチャのコンテナイメージをビルドすることができる。なお、この手法はmacOSに限らず、x86_64-linuxからaarch64-linux向けのクロスコンパイルなど、他の環境の組み合わせでも適用可能である。例えばCI環境でx86_64-linuxのランナーしか利用できない場合でも、aarch64-linux向けのコンテナイメージを効率的に生成できる。

この記事は、macOS（特にApple Silicon搭載機）でコンテナ開発を行っている方、ビルドプロセスを高速化したい方、Nixに興味がある方、そして複数アーキテクチャ向けのイメージを効率的に作成したい方に役立つ内容となっている。[cross-compiling-container-example](https://github.com/natsukium/cross-compiling-container-example)リポジトリをベースに、実際の実装方法と使い方を説明していく。

## 前提条件

この記事の内容を実践するには、いくつかのツールが必要である。まず、macOSにNixをインストールする必要があり、これは公式サイトの手順に従って`sh <(curl -L https://nixos.org/nix/install)`コマンドで行える。次に、コンテナイメージをロードして実行するためにDockerが必要で、Docker Desktop for MacやRancher Desktopなどの選択肢がある。さらに、基本的なNixの知識、特にflakeや設定ファイルの基本を理解していると作業がスムーズに進む。これらのツールをインストールしたら、次のセクションで実際の実装に進むことができる。

## クロスコンパイルとは何か？

クロスコンパイルとは、あるプラットフォーム（ホスト環境）で別のプラットフォーム（ターゲット環境）向けのコードをコンパイルすることである。例えば、macOS（aarch64-darwin）上でLinux（x86_64-linux）向けのバイナリを生成することが可能になる。これは特にコンテナイメージをビルドする際に非常に有用な技術である。

### 従来のアプローチと課題

従来、macOSでx86_64-linux向けのコンテナイメージをビルドする場合、いくつかの方法が用いられてきた。最も一般的なのはエミュレーション（QEMU）を使用する方法で、Docker Buildxを使用してQEMUによるエミュレーションでビルドを行う。これは`docker buildx build --platform linux/amd64,linux/arm64 -t myapp:latest .`のようなコマンドで実行できるが、エミュレーションによるパフォーマンスの低下やビルド時間の長さが問題となる。

また、クラウドCI/CDサービスやリモートのLinuxマシンを利用してビルドするリモートビルド方式も存在するが、ネットワーク依存やセットアップの複雑さが課題となる。さらに、仮想マシンでLinuxを実行し、その中でビルドするネイティブLinux環境アプローチもあるが、これはオーバーヘッドが大きく、リソース消費が激しいという問題がある。

これらの従来手法は、特に開発の反復サイクルを頻繁に行う場合には効率が悪く、開発生産性に影響を与える。さらに、先述したように、macOSでは仮想化環境をネストすることが難しいため、コンテナ内でさらに仮想化やエミュレーションを行う構成が必要な場合に技術的な制約に直面することがある。

## Nixによるクロスコンパイルの仕組み

Nixは宣言的なパッケージマネージャであり、再現性の高いビルド環境を提供する。Nixの特徴的な機能の一つが、クロスコンパイルのネイティブサポートである。

### Nixのクロスコンパイルの特徴

Nixによるクロスコンパイルには、いくつかの重要な特徴がある。まず、設定ファイル（flake.nix）でビルド環境とターゲットアーキテクチャを宣言的に定義できる点が挙げられる。この宣言的なアプローチにより、ビルド環境の構成が明確になり、再現性が高まる。次に、ターゲットアーキテクチャに必要なコンパイラやライブラリを自動的に解決する機能がある。これにより、クロスコンパイルに必要な複雑な環境設定が大幅に簡略化される。

さらに、Nixの重要な特徴として再現性が挙げられる。同じ設定から毎回同じ結果が得られるため、「自分の環境では動く」といった問題を回避できる。また、QEMUなどのエミュレーションを使わずに直接クロスコンパイルを行うため、パフォーマンスが向上する点も大きな利点である。これにより、macOSからLinux向けのコンテナイメージをビルドする際に、従来のアプローチよりも高速なビルドが可能になる。

### クロスコンパイル用flake.nixの構造

典型的なクロスコンパイル用のflake.nixには、以下のような構造が含まれる。まず、必要な入力（inputs）として、nixpkgsとflake-utilsを指定する。次に、outputs部分で各システム向けの設定を定義する。この中で、ターゲットシステム用のパッケージセットとしてpkgsCrossを設定し、aarch64-linuxやx86_64-linux向けのクロスコンパイル環境を準備する。また、buildForTargetのような関数を定義して、指定したターゲット向けにビルドを行うロジックを実装する。

```nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        
        # ターゲットシステム用のパッケージセット
        pkgsCross = {
          aarch64-linux = pkgs.pkgsCross.aarch64-multiplatform;
          x86_64-linux = pkgs.pkgsCross.gnu64;
        };
        
        # クロスコンパイル関数
        buildForTarget = target: ...
        
      in {
        packages = {
          aarch64-linux = buildForTarget "aarch64-linux";
          x86_64-linux = buildForTarget "x86_64-linux";
          default = self.packages.${system}.aarch64-linux;
        };
      }
    );
}
```

この構造により、単一の設定ファイルから様々なターゲットアーキテクチャ向けのビルドを行うことができる。これは、CI環境でのビルドの一貫性を確保するのにも役立つ。例えば、x86_64-linuxのCI環境からaarch64-linux向けのコンテナイメージをビルドする際にも、同じ設定ファイルを使用できる。

## 実装例：Rustアプリケーションのクロスコンパイル

実際の例として、シンプルなRust製Webサーバーをクロスコンパイルし、異なるアーキテクチャ向けのコンテナイメージを作成する方法を見ていく。

### プロジェクト構成

サンプルプロジェクトの構成は非常にシンプルで、基本的にflake.nixという設定ファイル、flake.lockというバージョンロックファイル、そしてsrcディレクトリ内にRustアプリケーションのソースコード（Cargo.tomlとmain.rs）が含まれている。この構成はシンプルながらも、クロスコンパイルの概念を理解するには十分である。

```
.
├── flake.nix           # Nixの設定ファイル
├── flake.lock          # バージョンロックファイル
└── src                 # Rustアプリケーションのソースコード
    ├── Cargo.toml
    └── main.rs
```

### Rustアプリケーション

まず、サンプルプロジェクトで使用している非常にシンプルなWebサーバーアプリケーションを見てみる。このアプリケーションは、Axumというフレームワークを使用した簡単なHTTPサーバーで、"Hello, World!"というメッセージを返すエンドポイントを提供する。コードはシンプルだが、実際のクロスコンパイルのテストケースとしては十分な複雑さを持っている。

```rust
// src/main.rs
use std::net::SocketAddr;
use axum::{
    routing::get,
    Router,
};

#[tokio::main]
async fn main() {
    // ルーターの設定
    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }));

    // サーバーアドレスの設定
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    println!("サーバーを起動しています: {}", addr);

    // サーバーの起動
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

このコードは、HTTP要求に応答する単純なWebサーバーを実装している。特に注目すべき点は、このコードが特定のアーキテクチャに依存していない点である。これにより、異なるターゲットアーキテクチャに対して容易にクロスコンパイルできる。

### flake.nixの詳細

次に、クロスコンパイルを可能にするflake.nixファイルを詳しく見ていく。このファイルはNixのクロスコンパイル機能を活用して、異なるアーキテクチャ向けのコンテナイメージビルドを実現している。

```nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    rust-overlay.url = "github:oxalica/rust-overlay";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, rust-overlay, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        overlays = [ (import rust-overlay) ];
        pkgs = import nixpkgs { inherit system overlays; };
        
        rust-toolchain = pkgs.rust-bin.stable.latest.default;
        
        # ターゲットアーキテクチャのリスト
        targets = [
          "aarch64-unknown-linux-musl"
          "x86_64-unknown-linux-musl"
        ];
        
        # 指定したターゲット向けにRustアプリケーションをビルドする関数
        buildRustApp = target:
          let
            targetTriple = pkgs.stdenv.hostPlatform.config;
            isNative = targetTriple == target;
            
            # クロスコンパイル用のツールチェーン
            rustTargetPlatform = if isNative then pkgs else
              (pkgs.rust-bin.stable.latest.default.override {
                targets = [ target ];
              });
              
            # musl向けのクロスコンパイル
            muslPkgs = if isNative then pkgs else
              (if target == "aarch64-unknown-linux-musl" then
                pkgs.pkgsCross.aarch64-multiplatform-musl
              else if target == "x86_64-unknown-linux-musl" then
                pkgs.pkgsCross.musl64
              else
                throw "Unsupported target platform: ${target}");
                
          in muslPkgs.stdenv.mkDerivation {
            name = "rust-web-server-${target}";
            src = ./.;
            
            nativeBuildInputs = with pkgs; [
              rustTargetPlatform
              pkg-config
            ];
            
            buildPhase = ''
              export CARGO_HOME=$out/cargo
              mkdir -p $CARGO_HOME
              cargo build --release --target ${target}
            '';
            
            installPhase = ''
              mkdir -p $out/bin
              cp target/${target}/release/rust-web-server $out/bin/
            '';
          };
          
        # コンテナイメージをビルドする関数
        buildContainerImage = target:
          let
            app = buildRustApp target;
            targetArch = if target == "aarch64-unknown-linux-musl" then "arm64" else "amd64";
          in
            pkgs.dockerTools.buildImage {
              name = "rust-web-server";
              tag = targetArch;
              
              contents = [
                app
                pkgs.coreutils
              ];
              
              config = {
                Cmd = [ "${app}/bin/rust-web-server" ];
                ExposedPorts = {
                  "3000/tcp" = {};
                };
              };
            };
      in
      {
        packages = {
          # 各ターゲット向けのパッケージ
          aarch64-container = buildContainerImage "aarch64-unknown-linux-musl";
          x86_64-container = buildContainerImage "x86_64-unknown-linux-musl";
          default = self.packages.${system}.aarch64-container;
        };
        
        # 開発環境
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            rust-toolchain
          ];
        };
      }
    );
}
```

このflake.nixファイルの構成を詳しく見ていくと、まず最初にinputsセクションで必要なデータソースを指定している。nixpkgsはNixのパッケージコレクション、rust-overlayはRustのバージョン管理を容易にするためのオーバーレイ、flake-utilsはflakeの記述を簡略化するためのユーティリティ集である。

その後のoutputsセクションでは、各システム向けの設定を行っている。まず、Rustのツールチェーンを設定し、ターゲットアーキテクチャとして「aarch64-unknown-linux-musl」と「x86_64-unknown-linux-musl」を定義している。ここで注目すべきは、muslライブラリを使用している点である。muslは軽量のC標準ライブラリで、静的リンクに適しており、これによりコンテナイメージのサイズを小さく保ちながら依存関係の問題を回避できる。

buildRustApp関数は、指定したターゲット向けにRustアプリケーションをクロスコンパイルする核心部分である。この関数では、まず現在のシステムがターゲットと同じかどうかを確認し、異なる場合はクロスコンパイル用の設定を行う。特に重要なのは、muslPkgsの部分で、ターゲットアーキテクチャに応じて適切なクロスコンパイルツールチェーンを選択している。

```nix
muslPkgs = if isNative then pkgs else
  (if target == "aarch64-unknown-linux-musl" then
    pkgs.pkgsCross.aarch64-multiplatform-musl
  else if target == "x86_64-unknown-linux-musl" then
    pkgs.pkgsCross.musl64
  else
    throw "Unsupported target platform: ${target}");
```

buildContainerImage関数は、クロスコンパイルされたバイナリを含むDockerイメージを作成する。ここでは、NixのdockerTools.buildImage機能を使用して、最小限の内容を持つコンテナイメージを構築している。

最後に、packagesセクションでは、aarch64-containerとx86_64-containerという二つのパッケージを定義し、それぞれ対応するアーキテクチャ向けのコンテナイメージをビルドする設定をしている。また、devShellsセクションでは開発環境も提供しており、これにより同じリポジトリ内で開発とビルドの両方をシームレスに行うことができる。

この設定により、macOS（aarch64-darwin）上でaarch64-linuxやx86_64-linux向けのコンテナイメージを直接クロスコンパイルでき、エミュレーションによるオーバーヘッドなしに効率的なビルドが可能になる。また、同様の手法でx86_64-linux環境からaarch64-linux向けのビルドも可能であり、CI/CD環境での活用にも適している。

### コンテナイメージの作成と実行

上記の設定ファイルを使用して実際にコンテナイメージをビルドする手順は非常にシンプルである。Nixのエクスペリメンタル機能であるflakesとnix-commandを有効にした状態で、以下のコマンドを実行する。

```bash
# ARM64向けイメージのビルド
nix --extra-experimental-features "flakes nix-command" build .#aarch64-container

# x86_64向けイメージのビルド
nix --extra-experimental-features "flakes nix-command" build .#x86_64-container
```

ビルドが完了すると、`./result`にコンテナイメージが生成される。このイメージファイルをDockerにロードするには、以下のコマンドを使用する。

```bash
# イメージをDockerにロード
docker load < ./result
```

ロードが完了したら、プラットフォームを指定してDockerでイメージを実行できる。プラットフォームの指定は`--platform`フラグで行い、これによりmacOS上でも異なるアーキテクチャのコンテナを実行できる。

```bash
# ARM64イメージの実行
docker run --platform linux/arm64 -p 3000:3000 rust-web-server:arm64

# x86_64イメージの実行
docker run --platform linux/amd64 -p 3000:3000 rust-web-server:amd64
```

実行後、ブラウザで`http://localhost:3000`にアクセスすると、"Hello, World!"というメッセージが表示される。このように、Nixを使用したクロスコンパイルアプローチでは、macOS上で直接異なるアーキテクチャ向けのコンテナイメージをビルドし、それをDockerで実行するまでの一連のプロセスをスムーズに行うことができる。これは特に開発環境での迅速なイテレーションに大きな価値をもたらす。

## パフォーマンス比較

Nixによるクロスコンパイルアプローチの主な利点の一つはパフォーマンスです。従来のアプローチと比較して、ビルド時間と効率性が大幅に向上します。

### エミュレーションとの比較

以下は、Apple Silicon MacでのRustアプリケーションのクロスコンパイルにおける、異なるアプローチの比較です（サンプルプロジェクトでの実測値）：

| アプローチ | x86_64-linux向けビルド時間 | メモリ使用量 |
|---------|----------------------|---------|
| Docker Buildx（QEMU） | 約3〜5分 | 中〜高 |
| Nix クロスコンパイル   | 約30秒〜1分 | 低〜中 |

これは、QEMUによるエミュレーションを使わないため、直接ネイティブコンパイラがコードを処理できるためです。特に複雑なプロジェクトや大規模なアプリケーションでは、この差はさらに顕著になります。

### キャッシュの利点

Nixのもう一つの大きな利点は、ビルドの出力が決定論的にキャッシュされることです。同じ入力（コードやライブラリ）に対しては、再ビルドの必要がなく、すぐに前回のビルド結果を再利用できます。これにより、CI/CDパイプラインでの反復的なビルドが非常に高速になります。

## ベストプラクティスと注意点

Nixを使ったクロスコンパイルを効果的に行うための、いくつかのベストプラクティスと注意点を紹介します。

### 1. 静的リンクの活用

できるだけ静的リンク（muslなど）を使用することで、コンテナイメージのサイズを小さく保ちながら、依存関係の問題を回避できます。上記の例では、muslを使用して静的リンクを行っています。

### 2. 共通の依存関係を抽出

複数のターゲットアーキテクチャ向けにビルドする場合、共通の依存関係やビルドロジックを抽出し、重複を避けることが重要です。flake.nixファイル内で関数を適切に設計することで、コードの重複を減らし、メンテナンス性を向上させることができます。

### 3. CIパイプラインとの統合

GitHubアクションやその他のCIシステムとNixを統合することで、継続的に複数アーキテクチャ向けのコンテナイメージをビルドできます。例えば、次のようなGitHubワークフローを作成できます：

```yaml
name: Build Multi-Arch Containers

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: cachix/install-nix-action@v20
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes
      
      - name: Build ARM64 Container
        run: nix build .#aarch64-container
      
      - name: Build x86_64 Container
        run: nix build .#x86_64-container
      
      # コンテナイメージのプッシュなど、追加のステップ
```

### 4. システム依存の問題に注意

クロスコンパイルは多くの場合スムーズに機能しますが、特定のライブラリやシステム依存の機能を使用する場合には問題が発生することがあります。そのような場合は、条件付きコンパイルや互換性のあるライブラリの選択など、対応策を検討する必要があります。

## まとめ

この記事では、Nixを使ってmacOS上で直接異なるアーキテクチャ向けのコンテナイメージをクロスコンパイルする方法を紹介しました。

主なポイントをまとめると：

1. **従来の問題点**: macOSでのコンテナイメージビルドは、特に異なるアーキテクチャ向けの場合、エミュレーションを使用するため遅く非効率でした。

2. **Nixによる解決策**: Nixのクロスコンパイル機能を活用することで、QEMUなどのエミュレーションを使わずに直接異なるアーキテクチャ向けのコンテナイメージをビルドできます。

3. **メリット**:
   - ビルド時間の短縮
   - リソース使用量の削減
   - 再現性の高いビルド
   - 複数アーキテクチャの同時サポート

4. **実装例**: flake.nixを使用して、Rustアプリケーションを異なるアーキテクチャ向けにクロスコンパイルし、コンテナイメージとして構築する方法を示しました。

この方法を使うことで、macOSユーザーはより効率的にマルチアーキテクチャのコンテナ開発を行うことができます。特にApple Silicon搭載のMacを使用している開発者にとって、この方法は開発ワークフローの大幅な改善をもたらすでしょう。

## 参考リンク

- [Nix公式ドキュメント](https://nixos.org/learn.html)
- [Nixpkgsクロスコンパイルガイド](https://nixos.wiki/wiki/Cross_Compiling)
- [Rustクロスコンパイル](https://rust-lang.github.io/rustup/cross-compilation.html)
- [サンプルリポジトリ](https://github.com/natsukium/cross-compiling-container-example)
