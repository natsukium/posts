---
title: "macOSネイティブでコンテナイメージをクロスコンパイルする"
emoji: "🐋"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nix", "container", "docker"]
published: true
---

## はじめに

macOSでコンテナ開発を行うとき、特にApple Silicon（M1/M2）搭載のMacを使用している場合、マルチアーキテクチャ対応のコンテナイメージを作成するには課題があります。

macOSでのコンテナ実行環境は、主に次のような仮想化技術に依存しています：

- **Docker Desktop**: 従来はHyperKit（macOSのHypervisor.framework上に構築）を利用していましたが、現在ではApple Silicon向けにVirtualization Frameworkも採用。LinuxKit VMを使用してコンテナを実行します。
- **Rancher Desktop**: Lima VMを活用しており、内部的にはQEMUを使用しています。最近のバージョンではApple Silicon向けにVirtualization Frameworkのサポートも追加されています。
- **Lima**: 「macOS向けのWSL2」とも呼ばれ、QEMUを利用して軽量Linuxマシンを実行します。

これらの仮想化技術は便利ですが、特に異なるアーキテクチャ（例：Intel/AMD向けのx86_64）向けのコンテナを実行・ビルドする場合、エミュレーションによるオーバーヘッドが発生し、ビルド時間の長さやリソース消費の問題が生じます。

この記事では、Nixを活用してmacOS上で直接異なるアーキテクチャ（aarch64-linuxやx86_64-linux）向けのコンテナイメージをクロスコンパイルする方法を紹介します。この方法を使うことで、仮想化やエミュレーションを使わずに、高速かつ効率的にマルチアーキテクチャのコンテナイメージをビルドすることができます。

対象読者は次のような方です：
- macOS（特にApple Silicon搭載機）でコンテナ開発を行っている方
- ビルドプロセスを高速化したい方
- Nixに興味がある方
- 複数アーキテクチャ向けのイメージを効率的に作成したい方

[cross-compiling-container-example](https://github.com/natsukium/cross-compiling-container-example)リポジトリをベースに、実際の実装方法と使い方を説明していきます。

## 前提条件

この記事の内容を実践するには、以下のツールが必要です：

1. **Nix**: macOSにNixをインストールする必要があります。インストール方法は[公式サイト](https://nixos.org/download.html)を参照してください。
   ```bash
   sh <(curl -L https://nixos.org/nix/install)
   ```

2. **Docker**: コンテナイメージをロードして実行するためにDockerが必要です。
   - [Docker Desktop for Mac](https://docs.docker.com/desktop/install/mac-install/)
   - または[Rancher Desktop](https://rancherdesktop.io/)などの代替ツール

3. **基本的なNixの知識**: flakeや設定ファイルの基本を理解していると役立ちます。

これらのツールをインストールしたら、次のセクションで実際の実装に進みます。

## クロスコンパイルとは何か？

クロスコンパイルとは、あるプラットフォーム（ホスト環境）で別のプラットフォーム（ターゲット環境）向けのコードをコンパイルすることです。例えば、macOS（aarch64-darwin）上でLinux（x86_64-linux）向けのバイナリを生成することが可能になります。

### 従来のアプローチと課題

従来、macOSでx86_64-linux向けのコンテナイメージをビルドする場合、次のような方法が一般的でした：

1. **エミュレーション（QEMU）**: Docker Buildxを使用し、QEMUによるエミュレーションでビルドする方法です。しかし、エミュレーションはパフォーマンスが低下し、ビルド時間が長くなる問題があります。

   ```bash
   docker buildx build --platform linux/amd64,linux/arm64 -t myapp:latest .
   ```

2. **リモートビルド**: クラウドCI/CDサービスやリモートのLinuxマシンを利用してビルドする方法です。ネットワーク依存やセットアップの複雑さが課題です。

3. **ネイティブLinux環境**: 仮想マシンでLinuxを実行し、その中でビルドする方法です。オーバーヘッドが大きく、リソース消費が激しいという問題があります。

これらの方法はいずれも、特に開発の反復サイクルを頻繁に行う場合には効率が悪いです。

## Nixによるクロスコンパイルの仕組み

Nixは宣言的なパッケージマネージャであり、再現性の高いビルド環境を提供します。Nixの特徴的な機能の一つが、クロスコンパイルのネイティブサポートです。

### Nixのクロスコンパイルの特徴

1. **宣言的な設定**: 設定ファイル（flake.nix）でビルド環境とターゲットアーキテクチャを宣言的に定義できます。

2. **依存関係の自動解決**: ターゲットアーキテクチャに必要なコンパイラやライブラリを自動的に解決します。

3. **再現性**: 同じ設定から毎回同じ結果が得られるため、「自分の環境では動く」問題を回避できます。

4. **エミュレーションなし**: QEMUなどのエミュレーションを使わずに直接クロスコンパイルを行うため、パフォーマンスが向上します。

### クロスコンパイル用flake.nixの構造

典型的なクロスコンパイル用のflake.nixは次のような構造になります：

```nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        
        # ターゲットシステム用のパッケージセット
        pkgsCross = {
          aarch64-linux = pkgs.pkgsCross.aarch64-multiplatform;
          x86_64-linux = pkgs.pkgsCross.gnu64;
        };
        
        # クロスコンパイル関数
        buildForTarget = target: ...
        
      in {
        packages = {
          aarch64-linux = buildForTarget "aarch64-linux";
          x86_64-linux = buildForTarget "x86_64-linux";
          default = self.packages.${system}.aarch64-linux;
        };
      }
    );
}
```

この構造により、さまざまなターゲットアーキテクチャ向けのビルドを単一の設定ファイルから行うことができます。

## 実装例：Rustアプリケーションのクロスコンパイル

実際の例として、シンプルなRust製Webサーバーをクロスコンパイルし、異なるアーキテクチャ向けのコンテナイメージを作成する方法を見ていきましょう。

### プロジェクト構成

サンプルプロジェクトは次のような構成になっています：

```
.
├── flake.nix           # Nixの設定ファイル
├── flake.lock          # バージョンロックファイル
└── src                 # Rustアプリケーションのソースコード
    ├── Cargo.toml
    └── main.rs
```

### Rustアプリケーション

まず、非常にシンプルなWebサーバーアプリケーションを見てみましょう：

```rust
// src/main.rs
use std::net::SocketAddr;
use axum::{
    routing::get,
    Router,
};

#[tokio::main]
async fn main() {
    // ルーターの設定
    let app = Router::new()
        .route("/", get(|| async { "Hello, World!" }));

    // サーバーアドレスの設定
    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    println!("サーバーを起動しています: {}", addr);

    // サーバーの起動
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```

このアプリケーションは、Axumというフレームワークを使用した簡単なHTTPサーバーで、"Hello, World!"というメッセージを返すエンドポイントを提供します。

### flake.nixの詳細

次に、クロスコンパイルを可能にするflake.nixファイルを詳しく見ていきましょう：

```nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    rust-overlay.url = "github:oxalica/rust-overlay";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, rust-overlay, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        overlays = [ (import rust-overlay) ];
        pkgs = import nixpkgs { inherit system overlays; };
        
        rust-toolchain = pkgs.rust-bin.stable.latest.default;
        
        # ターゲットアーキテクチャのリスト
        targets = [
          "aarch64-unknown-linux-musl"
          "x86_64-unknown-linux-musl"
        ];
        
        # 指定したターゲット向けにRustアプリケーションをビルドする関数
        buildRustApp = target:
          let
            targetTriple = pkgs.stdenv.hostPlatform.config;
            isNative = targetTriple == target;
            
            # クロスコンパイル用のツールチェーン
            rustTargetPlatform = if isNative then pkgs else
              (pkgs.rust-bin.stable.latest.default.override {
                targets = [ target ];
              });
              
            # musl向けのクロスコンパイル
            muslPkgs = if isNative then pkgs else
              (if target == "aarch64-unknown-linux-musl" then
                pkgs.pkgsCross.aarch64-multiplatform-musl
              else if target == "x86_64-unknown-linux-musl" then
                pkgs.pkgsCross.musl64
              else
                throw "Unsupported target platform: ${target}");
                
          in muslPkgs.stdenv.mkDerivation {
            name = "rust-web-server-${target}";
            src = ./.;
            
            nativeBuildInputs = with pkgs; [
              rustTargetPlatform
              pkg-config
            ];
            
            buildPhase = ''
              export CARGO_HOME=$out/cargo
              mkdir -p $CARGO_HOME
              cargo build --release --target ${target}
            '';
            
            installPhase = ''
              mkdir -p $out/bin
              cp target/${target}/release/rust-web-server $out/bin/
            '';
          };
          
        # コンテナイメージをビルドする関数
        buildContainerImage = target:
          let
            app = buildRustApp target;
            targetArch = if target == "aarch64-unknown-linux-musl" then "arm64" else "amd64";
          in
            pkgs.dockerTools.buildImage {
              name = "rust-web-server";
              tag = targetArch;
              
              contents = [
                app
                pkgs.coreutils
              ];
              
              config = {
                Cmd = [ "${app}/bin/rust-web-server" ];
                ExposedPorts = {
                  "3000/tcp" = {};
                };
              };
            };
      in
      {
        packages = {
          # 各ターゲット向けのパッケージ
          aarch64-container = buildContainerImage "aarch64-unknown-linux-musl";
          x86_64-container = buildContainerImage "x86_64-unknown-linux-musl";
          default = self.packages.${system}.aarch64-container;
        };
        
        # 開発環境
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            rust-toolchain
          ];
        };
      }
    );
}
```

この`flake.nix`では、次のことを行っています：

1. **Rustオーバーレイの使用**: Rustのバージョン管理を簡単にするためのオーバーレイを使用しています。
2. **複数ターゲットの定義**: `aarch64-unknown-linux-musl`と`x86_64-unknown-linux-musl`の2つのターゲットを定義しています。
3. **クロスコンパイル関数**: `buildRustApp`関数では、指定したターゲット向けにRustアプリケーションをクロスコンパイルします。
4. **コンテナイメージビルド**: `buildContainerImage`関数では、クロスコンパイルされたバイナリを含むDockerイメージを作成します。
5. **開発環境の提供**: `devShells.default`で開発環境も提供しています。

特に重要なのは、`muslPkgs`の部分です。ここでは、ターゲットアーキテクチャに応じて適切なクロスコンパイルツールチェーンを選択しています：

```nix
muslPkgs = if isNative then pkgs else
  (if target == "aarch64-unknown-linux-musl" then
    pkgs.pkgsCross.aarch64-multiplatform-musl
  else if target == "x86_64-unknown-linux-musl" then
    pkgs.pkgsCross.musl64
  else
    throw "Unsupported target platform: ${target}");
```

また、静的リンクのためにMuslライブラリを使用しており、これによりコンテナイメージのサイズを小さく保ちながら、依存関係の問題を回避しています。

### コンテナイメージの作成

上記の設定ファイルを使って、次のコマンドでコンテナイメージをビルドできます：

```bash
# ARM64向けイメージのビルド
nix --extra-experimental-features "flakes nix-command" build .#aarch64-container

# x86_64向けイメージのビルド
nix --extra-experimental-features "flakes nix-command" build .#x86_64-container
```

ビルドが完了すると、`./result`にコンテナイメージが生成されます。これをDockerにロードするには：

```bash
# ARM64向けイメージをロード
docker load < ./result

# x86_64向けイメージをロード
docker load < ./result
```

### イメージの実行

ロードしたイメージを実行するには、プラットフォームを指定してdocker runコマンドを使用します：

```bash
# ARM64イメージの実行
docker run --platform linux/arm64 -p 3000:3000 rust-web-server:arm64

# x86_64イメージの実行
docker run --platform linux/amd64 -p 3000:3000 rust-web-server:amd64
```

ブラウザで`http://localhost:3000`にアクセスすると、"Hello, World!"というメッセージが表示されます。
